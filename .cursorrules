# Development Workflow Rules

## Orden de Implementación de Nuevas Features

Al implementar un nuevo módulo o feature en el sistema, seguir estrictamente este orden en 3 fases:

### Fase 1: Domain Layer (Entidades y Lógica de Negocio)

**Tarea: Crear entidades, value objects y enums**

1. **Enums**: Crear todos los enums necesarios en `domain/enums/`
   - Usar `str, Enum` como base
   - Documentar cada valor
   - ⚠️ **REGLA CRÍTICA**: Los enums DEBEN terminar con `Enum`:
     * ✅ `class ViewTypeEnum(str, Enum):`
     * ✅ `class WorkflowTypeEnum(str, Enum):`
     * ✅ `class CommentReviewStatusEnum(str, Enum):`
     * ❌ `class ViewType(str, Enum):` (sin sufijo Enum - INCORRECTO)

2. **Value Objects**: Crear value objects en `domain/value_objects/`
   - Inmutables
   - Con validaciones propias
   - Métodos de comparación
   - ⚠️ **REGLA CRÍTICA**: Los Value Objects de IDs DEBEN heredar de `BaseId`:
     * ✅ `class CompanyId(BaseId): value: str`
     * ✅ `class JobPositionWorkflowId(BaseId): value: str`
     * ❌ `class CompanyId:` (sin heredar BaseId - INCORRECTO)
     * `BaseId` proporciona `generate()`, `from_string()`, `__str__()`, `__eq__()`, `__hash__()`

3. **Entidades**: Crear entidades en `domain/entities/`
   - Constructor con todos los parámetros requeridos (sin valores por defecto)
   - Propiedades públicas (NO usar getters/setters)
   - Factory method `create()` con valores por defecto y validaciones
   - Factory method `update()` que recibe TODOS los atributos actualizables
   - Para cambios de status: método específico por cada transición
     * Ejemplo: `activate()`, `suspend()`, `archive()`
     * NO permitir cambio directo de status
   - Los métodos de factory retornan la entidad

**Ejemplo de Entidad:**
```python
@dataclass
class Company:
    id: CompanyId
    name: str
    domain: str
    status: CompanyStatus
    created_at: datetime
    updated_at: datetime

    @classmethod
    def create(
        cls,
        name: str,
        domain: str,
        id: Optional[CompanyId] = None,
        status: CompanyStatus = CompanyStatus.ACTIVE
    ) -> "Company":
        # Validaciones
        # Valores por defecto
        return cls(...)

    def update(
        self,
        name: str,
        domain: str,
    ) -> None:
        # Validaciones
        self.name = name
        self.domain = domain
        self.updated_at = datetime.now()

    def suspend(self) -> None:
        # Validaciones
        self.status = CompanyStatus.SUSPENDED
        self.updated_at = datetime.now()

    def activate(self) -> None:
        # Logic and validations
        self.status = CompanyStatus.ACTIVE
        self.updated_at = datetime.now()
```

**FIN DE FASE 1** - Confirmar con el usuario antes de continuar

---

### Fase 2: Infrastructure Layer (Persistencia)

**Tarea: Crear repositorios, mappers, modelos y migraciones**

1. **Interface del Repositorio**: Crear en `domain/infrastructure/{entity}_repository_interface.py`
   - Abstract Base Class (ABC)
   - Métodos abstractos que retornan entidades de dominio

2. **Modelo SQLAlchemy**: Crear en `infrastructure/models/{entity}_model.py`
   - Hereda de Base
   - Define tabla y columnas
   - Relaciones si aplica

3. **Repositorio**: Implementar en `infrastructure/repositories/{entity}_repository.py`
   - Implementa la interface del dominio
   - Convierte modelos ↔ entidades
   - Métodos `_to_domain()` y `_to_model()`

4. **Mappers**: Crear en `application/mappers/` o `presentation/mappers/`
   - Entity → DTO en application layer
   - DTO → Response en presentation layer

5. **Migración**: Crear con `make revision m="add {entity} table"`
   - Revisar migración generada
   - Ajustar si es necesario
   - Ejecutar con `make migrate`

**FIN DE FASE 2** - Confirmar con el usuario antes de continuar

---

### Fase 3: Application & Presentation Layer (API)

**Tarea: Crear endpoints, requests, actions, comandos y queries**

1. **Commands** (operaciones de escritura): Crear en `application/commands/`
   - Command dataclass con los datos necesarios
   - CommandHandler que NO retorna valores (void)
   - Usar repositorio a través de la interface
   - ⚠️ **TIPADO CRÍTICO**: Los campos deben usar Value Objects directamente, NO strings:
     * ✅ `company_id: CompanyId`, `user_id: UserId`, `role: CompanyUserRole`
     * ❌ `company_id: str`, `user_id: str`, `role: str` (INCORRECTO)
   - La conversión string → value object se hace en Controller/Router, NO en Handler

2. **Queries** (operaciones de lectura): Crear en `application/queries/`
   - Query dataclass con criterios de búsqueda
   - QueryHandler que retorna DTOs
   - Usar repositorio a través de la interface
   - ⚠️ **TIPADO CRÍTICO**: Los campos deben usar Value Objects directamente, NO strings:
     * ✅ `company_id: CompanyId`, `token: InvitationToken`, `user_id: UserId`
     * ❌ `company_id: str`, `token: str`, `user_id: str` (INCORRECTO)
   - La conversión string → value object se hace en Controller/Router, NO en Handler

3. **DTOs**: Crear en `application/dtos/`
   - Dataclasses para transferencia de datos
   - Método `from_entity()` para conversión

4. **Request Schemas**: Crear en `presentation/schemas/`
   - Modelos Pydantic para validación de input
   - Nombrar como `{Entity}CreateRequest`, `{Entity}UpdateRequest`

5. **Response Schemas**: Crear en `presentation/schemas/`
   - Modelos Pydantic para respuestas
   - Nombrar como `{Entity}Response`, `{Entity}ListResponse`

6. **Controllers**: Crear en `presentation/controllers/`
   - Lógica de orquestación
   - Llama a CommandBus/QueryBus
   - Usa mappers para convertir DTOs a Responses
   - NO lógica de negocio aquí

7. **Routers**: Crear en `presentation/routers/`
   - Define endpoints
   - Valida requests
   - Llama a controllers
   - Retorna responses
   - NO lógica aquí, solo paso de datos

8. **Registrar en Container**: Actualizar `core/container.py`
   - Registrar repositorios
   - Registrar handlers
   - Registrar controllers

**FIN DE FASE 3** - Feature completamente implementada

---

## Reglas Generales

### Entidades
- Constructor sin valores por defecto
- Propiedades públicas (no private con @property)
- Factory methods para creación y actualización
- Métodos específicos para transiciones de estado
- Mutabilidad: los métodos modifican la instancia directamente (NO retornan nuevas instancias)

### Repositorios
- Interface en domain layer
- Implementación en infrastructure layer
- Retornan siempre entidades de dominio
- Nunca exponer modelos SQLAlchemy fuera de infrastructure

### Commands vs Queries (CQRS)
- Commands: void (no retornan valores)
- Queries: retornan DTOs
- Handlers en application layer
- Separación clara de responsabilidades
- **TIPADO CRÍTICO**: Commands y Queries DEBEN usar Value Objects directamente:
  - IDs: `CompanyId`, `UserId`, `CompanyUserId`, etc. (NO `str`)
  - Tokens: `InvitationToken`, etc. (NO `str`)
  - Enums: `CompanyUserRole`, etc. (NO `str`)
  - Conversión string → value object: SOLO en Controller/Router

### Data Flow
```
Request → Command/Query → Handler → Repository → Entity
Entity → Repository → DTO → Mapper → Response
```

### Naming Conventions
- Entities: `Company`, `CompanyWorkflow`
- Models: `CompanyModel`, `CompanyWorkflowModel`
- Commands: `CreateCompanyCommand`, `UpdateCompanyCommand`
- Queries: `GetCompanyByIdQuery`, `ListCompaniesQuery`
- Handlers: `CreateCompanyCommandHandler`, `GetCompanyByIdQueryHandler`
- DTOs: `CompanyDto`, `CompanyWorkflowDto`
- Requests: `CreateCompanyRequest`, `UpdateCompanyRequest`
- Responses: `CompanyResponse`, `CompanyListResponse`
- Controllers: `CompanyController`
- Routers: `company_router`
- **Enums**: DEBEN terminar con `Enum`: `ViewTypeEnum`, `WorkflowTypeEnum`, `CommentReviewStatusEnum`
- **Value Object IDs**: DEBEN heredar de `BaseId`: `CompanyId(BaseId)`, `JobPositionWorkflowId(BaseId)`

### Testing
Cada fase debe tener tests:
- Fase 1: Tests unitarios de entidades y lógica de dominio
- Fase 2: Tests de repositorios (con DB de test)
- Fase 3: Tests de endpoints (integration tests)

---

## Workflow Summary

```
Fase 1: Entidades + Value Objects + Enums → STOP ✋
         ↓ (confirmar con usuario)
Fase 2: Repos + Mappers + Models + Migrations → STOP ✋
         ↓ (confirmar con usuario)
Fase 3: Endpoints + Requests + Actions + Commands + Queries → DONE ✅
```

**IMPORTANTE**: No avanzar a la siguiente fase sin confirmación del usuario.
