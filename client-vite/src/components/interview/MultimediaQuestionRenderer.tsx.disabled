import React, { useState, useRef, useEffect } from 'react';
import {
  ConversationalQuestion,
  QuestionDifficulty,
  QuestionCategory
} from '../../types/interview';

interface MultimediaAsset {
  id: string;
  type: 'image' | 'video' | 'audio' | 'document' | 'code_snippet' | 'diagram';
  url: string;
  title?: string;
  description?: string;
  metadata?: {
    duration?: number; // for audio/video
    size?: number; // file size in bytes
    format?: string; // file format
    dimensions?: { width: number; height: number }; // for images/videos
    language?: string; // for code snippets
  };
}

interface MultimediaQuestion extends ConversationalQuestion {
  multimedia_assets?: MultimediaAsset[];
  requires_multimedia_response?: boolean;
  accepted_response_types?: ('text' | 'audio' | 'video' | 'image' | 'file')[];
}

interface MultimediaQuestionRendererProps {
  question: MultimediaQuestion;
  onMediaLoad?: (assetId: string) => void;
  onMediaError?: (assetId: string, error: string) => void;
  onMediaInteraction?: (assetId: string, action: string, timestamp?: number) => void;
  disabled?: boolean;
  allowFullscreen?: boolean;
}

const MultimediaQuestionRenderer: React.FC<MultimediaQuestionRendererProps> = ({
  question,
  onMediaLoad,
  onMediaError,
  onMediaInteraction,
  disabled = false,
  allowFullscreen = true
}) => {
  const [loadingAssets, setLoadingAssets] = useState<Set<string>>(new Set());
  const [errorAssets, setErrorAssets] = useState<Set<string>>(new Set());
  const [playbackStates, setPlaybackStates] = useState<Record<string, {
    playing: boolean;
    currentTime: number;
    duration: number;
  }>>({});
  const [fullscreenAsset, setFullscreenAsset] = useState<string | null>(null);
  const [imageZoom, setImageZoom] = useState<Record<string, number>>({});

  const mediaRefs = useRef<Record<string, HTMLVideoElement | HTMLAudioElement>>({});

  const handleMediaLoad = (assetId: string) => {
    setLoadingAssets(prev => {
      const newSet = new Set(prev);
      newSet.delete(assetId);
      return newSet;
    });

    const mediaElement = mediaRefs.current[assetId];
    if (mediaElement) {
      setPlaybackStates(prev => ({
        ...prev,
        [assetId]: {
          playing: false,
          currentTime: 0,
          duration: mediaElement.duration || 0
        }
      }));
    }

    onMediaLoad?.(assetId);
  };

  const handleMediaError = (assetId: string, error: string) => {
    setLoadingAssets(prev => {
      const newSet = new Set(prev);
      newSet.delete(assetId);
      return newSet;
    });

    setErrorAssets(prev => {
      const newSet = new Set(prev);
      newSet.add(assetId);
      return newSet;
    });

    onMediaError?.(assetId, error);
  };

  const handlePlayPause = (assetId: string) => {
    const mediaElement = mediaRefs.current[assetId] as HTMLVideoElement | HTMLAudioElement;
    if (!mediaElement) return;

    if (mediaElement.paused) {
      mediaElement.play();
      onMediaInteraction?.(assetId, 'play', mediaElement.currentTime);
    } else {
      mediaElement.pause();
      onMediaInteraction?.(assetId, 'pause', mediaElement.currentTime);
    }

    setPlaybackStates(prev => ({
      ...prev,
      [assetId]: {
        ...prev[assetId],
        playing: !mediaElement.paused
      }
    }));
  };

  const handleSeek = (assetId: string, time: number) => {
    const mediaElement = mediaRefs.current[assetId] as HTMLVideoElement | HTMLAudioElement;
    if (!mediaElement) return;

    mediaElement.currentTime = time;
    onMediaInteraction?.(assetId, 'seek', time);

    setPlaybackStates(prev => ({
      ...prev,
      [assetId]: {
        ...prev[assetId],
        currentTime: time
      }
    }));
  };

  const handleFullscreen = (assetId: string) => {
    if (fullscreenAsset === assetId) {
      setFullscreenAsset(null);
    } else {
      setFullscreenAsset(assetId);
      onMediaInteraction?.(assetId, 'fullscreen');
    }
  };

  const handleImageZoom = (assetId: string, delta: number) => {
    setImageZoom(prev => {
      const currentZoom = prev[assetId] || 1;
      const newZoom = Math.max(0.5, Math.min(3, currentZoom + delta));
      return { ...prev, [assetId]: newZoom };
    });
    onMediaInteraction?.(assetId, 'zoom', imageZoom[assetId] || 1);
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const formatDuration = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  const renderImageAsset = (asset: MultimediaAsset) => (
    <div className="relative bg-gray-100 rounded-lg overflow-hidden">
      {loadingAssets.has(asset.id) && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-200">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      )}

      {errorAssets.has(asset.id) ? (
        <div className="flex items-center justify-center h-48 bg-red-50 text-red-600">
          <div className="text-center">
            <svg className="w-12 h-12 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p className="text-sm">Failed to load image</p>
          </div>
        </div>
      ) : (
        <div className="relative group">
          <img
            src={asset.url}
            alt={asset.title || 'Question image'}
            className="w-full h-auto cursor-pointer transition-transform"
            style={{ transform: `scale(${imageZoom[asset.id] || 1})` }}
            onLoad={() => handleMediaLoad(asset.id)}
            onError={() => handleMediaError(asset.id, 'Failed to load image')}
            onClick={() => allowFullscreen && handleFullscreen(asset.id)}
          />

          {/* Image Controls */}
          <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
            <div className="flex space-x-1">
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  handleImageZoom(asset.id, 0.2);
                }}
                className="p-1 bg-black bg-opacity-50 text-white rounded hover:bg-opacity-70"
                title="Zoom In"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
              </button>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  handleImageZoom(asset.id, -0.2);
                }}
                className="p-1 bg-black bg-opacity-50 text-white rounded hover:bg-opacity-70"
                title="Zoom Out"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
                </svg>
              </button>
              {allowFullscreen && (
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleFullscreen(asset.id);
                  }}
                  className="p-1 bg-black bg-opacity-50 text-white rounded hover:bg-opacity-70"
                  title="View Fullscreen"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                  </svg>
                </button>
              )}
            </div>
          </div>

          {/* Image Info */}
          {asset.metadata?.dimensions && (
            <div className="absolute bottom-2 left-2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded">
              {asset.metadata.dimensions.width} × {asset.metadata.dimensions.height}
            </div>
          )}
        </div>
      )}

      {asset.title && (
        <div className="p-3">
          <h4 className="font-medium text-gray-900">{asset.title}</h4>
          {asset.description && (
            <p className="text-sm text-gray-600 mt-1">{asset.description}</p>
          )}
        </div>
      )}
    </div>
  );

  const renderVideoAsset = (asset: MultimediaAsset) => (
    <div className="relative bg-gray-100 rounded-lg overflow-hidden">
      {errorAssets.has(asset.id) ? (
        <div className="flex items-center justify-center h-48 bg-red-50 text-red-600">
          <div className="text-center">
            <svg className="w-12 h-12 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p className="text-sm">Failed to load video</p>
          </div>
        </div>
      ) : (
        <div className="relative">
          <video
            ref={(el) => el && (mediaRefs.current[asset.id] = el)}
            src={asset.url}
            className="w-full h-auto"
            onLoadedData={() => handleMediaLoad(asset.id)}
            onError={() => handleMediaError(asset.id, 'Failed to load video')}
            onTimeUpdate={(e) => {
              const video = e.target as HTMLVideoElement;
              setPlaybackStates(prev => ({
                ...prev,
                [asset.id]: {
                  ...prev[asset.id],
                  currentTime: video.currentTime,
                  playing: !video.paused
                }
              }));
            }}
            controls={false}
            poster={asset.metadata?.format === 'mp4' ? undefined : '/video-placeholder.png'}
          />

          {/* Custom Video Controls */}
          <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black to-transparent p-4">
            <div className="flex items-center space-x-3">
              <button
                onClick={() => handlePlayPause(asset.id)}
                className="text-white hover:text-gray-300"
                disabled={disabled}
              >
                {playbackStates[asset.id]?.playing ? (
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                ) : (
                  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h8m-10-4h1m9-4V5a1 1 0 00-1-1H8a1 1 0 00-1 1v1m3 0V5a1 1 0 011-1h4a1 1 0 011 1v1" />
                  </svg>
                )}
              </button>

              {/* Progress Bar */}
              <div className="flex-1">
                <input
                  type="range"
                  min="0"
                  max={playbackStates[asset.id]?.duration || 0}
                  value={playbackStates[asset.id]?.currentTime || 0}
                  onChange={(e) => handleSeek(asset.id, parseFloat(e.target.value))}
                  className="w-full h-1 bg-white bg-opacity-30 rounded-lg appearance-none cursor-pointer"
                  disabled={disabled}
                />
              </div>

              {/* Time Display */}
              <div className="text-white text-sm">
                {formatDuration(playbackStates[asset.id]?.currentTime || 0)} /
                {formatDuration(playbackStates[asset.id]?.duration || 0)}
              </div>

              {/* Fullscreen Button */}
              {allowFullscreen && (
                <button
                  onClick={() => handleFullscreen(asset.id)}
                  className="text-white hover:text-gray-300"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                  </svg>
                </button>
              )}
            </div>
          </div>
        </div>
      )}

      {asset.title && (
        <div className="p-3">
          <h4 className="font-medium text-gray-900">{asset.title}</h4>
          {asset.description && (
            <p className="text-sm text-gray-600 mt-1">{asset.description}</p>
          )}
        </div>
      )}
    </div>
  );

  const renderAudioAsset = (asset: MultimediaAsset) => (
    <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
      <div className="flex items-center space-x-4">
        <div className="flex-shrink-0">
          <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center">
            <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            </svg>
          </div>
        </div>

        <div className="flex-1">
          <div className="flex justify-between items-center mb-2">
            <h4 className="font-medium text-gray-900">{asset.title || 'Audio'}</h4>
            <div className="text-sm text-gray-500">
              {formatDuration(playbackStates[asset.id]?.duration || 0)}
            </div>
          </div>

          {errorAssets.has(asset.id) ? (
            <div className="text-red-600 text-sm">Failed to load audio</div>
          ) : (
            <div className="space-y-2">
              <audio
                ref={(el) => el && (mediaRefs.current[asset.id] = el)}
                src={asset.url}
                onLoadedData={() => handleMediaLoad(asset.id)}
                onError={() => handleMediaError(asset.id, 'Failed to load audio')}
                onTimeUpdate={(e) => {
                  const audio = e.target as HTMLAudioElement;
                  setPlaybackStates(prev => ({
                    ...prev,
                    [asset.id]: {
                      ...prev[asset.id],
                      currentTime: audio.currentTime,
                      playing: !audio.paused
                    }
                  }));
                }}
                className="hidden"
              />

              {/* Custom Audio Controls */}
              <div className="flex items-center space-x-3">
                <button
                  onClick={() => handlePlayPause(asset.id)}
                  className="text-blue-600 hover:text-blue-700"
                  disabled={disabled}
                >
                  {playbackStates[asset.id]?.playing ? (
                    <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                  ) : (
                    <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h8m-10-4h1m9-4V5a1 1 0 00-1-1H8a1 1 0 00-1 1v1m3 0V5a1 1 0 011-1h4a1 1 0 011 1v1" />
                    </svg>
                  )}
                </button>

                <div className="flex-1">
                  <input
                    type="range"
                    min="0"
                    max={playbackStates[asset.id]?.duration || 0}
                    value={playbackStates[asset.id]?.currentTime || 0}
                    onChange={(e) => handleSeek(asset.id, parseFloat(e.target.value))}
                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    disabled={disabled}
                  />
                </div>

                <div className="text-sm text-gray-500 min-w-[80px] text-right">
                  {formatDuration(playbackStates[asset.id]?.currentTime || 0)}
                </div>
              </div>
            </div>
          )}

          {asset.description && (
            <p className="text-sm text-gray-600 mt-1">{asset.description}</p>
          )}
        </div>
      </div>
    </div>
  );

  const renderDocumentAsset = (asset: MultimediaAsset) => (
    <div className="bg-white border border-gray-200 rounded-lg p-4">
      <div className="flex items-start space-x-3">
        <div className="flex-shrink-0">
          <div className="w-10 h-10 bg-gray-100 rounded-lg flex items-center justify-center">
            <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
          </div>
        </div>

        <div className="flex-1">
          <h4 className="font-medium text-gray-900">{asset.title || 'Document'}</h4>
          {asset.description && (
            <p className="text-sm text-gray-600 mt-1">{asset.description}</p>
          )}
          <div className="flex items-center justify-between mt-2">
            <div className="text-sm text-gray-500">
              {asset.metadata?.format?.toUpperCase()} • {asset.metadata?.size && formatFileSize(asset.metadata.size)}
            </div>
            <a
              href={asset.url}
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 hover:text-blue-800 text-sm font-medium"
              onClick={() => onMediaInteraction?.(asset.id, 'download')}
            >
              View Document →
            </a>
          </div>
        </div>
      </div>
    </div>
  );

  const renderCodeSnippetAsset = (asset: MultimediaAsset) => (
    <div className="bg-gray-900 rounded-lg overflow-hidden">
      {asset.title && (
        <div className="px-4 py-2 bg-gray-800 border-b border-gray-700">
          <div className="flex items-center justify-between">
            <h4 className="font-medium text-white">{asset.title}</h4>
            {asset.metadata?.language && (
              <span className="px-2 py-1 bg-gray-700 text-gray-300 text-xs rounded">
                {asset.metadata.language}
              </span>
            )}
          </div>
        </div>
      )}

      <div className="p-4">
        <pre className="text-green-400 text-sm overflow-x-auto">
          <code>{asset.description || '// Code snippet content would be here'}</code>
        </pre>
      </div>

      <div className="px-4 py-2 bg-gray-800 border-t border-gray-700">
        <button
          onClick={() => {
            navigator.clipboard.writeText(asset.description || '');
            onMediaInteraction?.(asset.id, 'copy');
          }}
          className="text-gray-400 hover:text-white text-sm flex items-center space-x-1"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
          </svg>
          <span>Copy Code</span>
        </button>
      </div>
    </div>
  );

  const renderAsset = (asset: MultimediaAsset) => {
    switch (asset.type) {
      case 'image':
        return renderImageAsset(asset);
      case 'video':
        return renderVideoAsset(asset);
      case 'audio':
        return renderAudioAsset(asset);
      case 'document':
        return renderDocumentAsset(asset);
      case 'code_snippet':
        return renderCodeSnippetAsset(asset);
      case 'diagram':
        return renderImageAsset(asset); // Treat diagrams as images
      default:
        return (
          <div className="bg-gray-100 border border-gray-300 rounded-lg p-4 text-center text-gray-600">
            Unsupported media type: {asset.type}
          </div>
        );
    }
  };

  if (!question.multimedia_assets || question.multimedia_assets.length === 0) {
    return null;
  }

  return (
    <div className="space-y-4">
      {question.multimedia_assets.map((asset) => (
        <div key={asset.id}>
          {renderAsset(asset)}
        </div>
      ))}

      {/* Fullscreen Modal */}
      {fullscreenAsset && allowFullscreen && (
        <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50">
          <div className="relative max-w-full max-h-full">
            <button
              onClick={() => setFullscreenAsset(null)}
              className="absolute top-4 right-4 text-white hover:text-gray-300 z-10"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>

            {(() => {
              const asset = question.multimedia_assets?.find(a => a.id === fullscreenAsset);
              if (!asset) return null;

              if (asset.type === 'image' || asset.type === 'diagram') {
                return (
                  <img
                    src={asset.url}
                    alt={asset.title || 'Fullscreen media'}
                    className="max-w-full max-h-full object-contain"
                  />
                );
              }

              if (asset.type === 'video') {
                return (
                  <video
                    src={asset.url}
                    controls
                    className="max-w-full max-h-full"
                    autoPlay={playbackStates[asset.id]?.playing}
                  />
                );
              }

              return null;
            })()}
          </div>
        </div>
      )}
    </div>
  );
};

export default MultimediaQuestionRenderer;