from dataclasses import dataclass
from typing import Optional

from src.company_bc.company.domain.entities.company_user_invitation import CompanyUserInvitation
from src.company_bc.company.domain.enums import CompanyUserRole
from src.company_bc.company.domain.value_objects import CompanyId, CompanyUserId
from src.company_bc.company.domain.value_objects.company_user_invitation_id import CompanyUserInvitationId
from src.company_bc.company.domain.infrastructure.company_user_invitation_repository_interface import (
    CompanyUserInvitationRepositoryInterface
)
from src.company_bc.company.domain.infrastructure.company_user_repository_interface import (
    CompanyUserRepositoryInterface
)
from src.company_bc.company.domain.infrastructure.company_repository_interface import (
    CompanyRepositoryInterface
)
from src.company_bc.company.domain.exceptions.company_exceptions import CompanyValidationError
from src.framework.application.command_bus import Command, CommandHandler
from src.framework.domain.interfaces.email_service import EmailServiceInterface
from core.config import settings


@dataclass
class InviteCompanyUserCommand(Command):
    """Command to invite a user to a company"""
    company_id: CompanyId
    email: str
    invited_by_user_id: CompanyUserId
    role: Optional[CompanyUserRole] = None  # Default to RECRUITER if not specified


class InviteCompanyUserCommandHandler(CommandHandler):
    """Handler for inviting a user to a company"""

    def __init__(
        self,
        invitation_repository: CompanyUserInvitationRepositoryInterface,
        company_user_repository: CompanyUserRepositoryInterface,
        company_repository: CompanyRepositoryInterface,
        email_service: EmailServiceInterface
    ):
        self.invitation_repository = invitation_repository
        self.company_user_repository = company_user_repository
        self.company_repository = company_repository
        self.email_service = email_service

    def execute(self, command: InviteCompanyUserCommand) -> None:
        """Execute the command - NO return value"""
        company_id = command.company_id
        invited_by_user_id = command.invited_by_user_id

        # Validate that the inviter exists and has permissions to invite
        inviter = self.company_user_repository.get_by_id(invited_by_user_id)
        if not inviter:
            raise CompanyValidationError(f"Inviter with id {invited_by_user_id} not found")

        # Validate that the email is not already linked to the company
        existing_invitation = self.invitation_repository.get_by_email_and_company(
            command.email,
            company_id
        )
        if existing_invitation and existing_invitation.is_pending():
            raise CompanyValidationError(
                f"User with email {command.email} already has a pending invitation for this company"
            )

        # Check if user is already a company user
        # This would require checking User repository, but for now we'll allow and handle in accept
        
        # Determine role (default to RECRUITER)
        role = command.role if command.role else CompanyUserRole.RECRUITER

        # Create invitation
        invitation_id = CompanyUserInvitationId.generate()
        invitation = CompanyUserInvitation.create(
            id=invitation_id,
            company_id=company_id,
            email=command.email,
            invited_by_user_id=invited_by_user_id,
            token=None,  # Will be generated by factory method
            expires_in_days=7
        )

        # Save invitation
        self.invitation_repository.save(invitation)

        # Send email notification
        try:
            # Get company name for email
            company = self.company_repository.get_by_id(company_id)
            company_name = company.name if company else "the company"
            
            # Get inviter name (optional, could be enhanced with User repository)
            inviter_name = None  # TODO: Get inviter name from User repository if needed
            
            # Generate invitation link
            invitation_link = f"{settings.FRONTEND_URL}/invitations/accept?token={invitation.token}"
            
            # Send email (async but we'll await it)
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    # If loop is already running, schedule as task
                    asyncio.create_task(
                        self.email_service.send_user_invitation(
                            email=command.email,
                            company_name=company_name,
                            invitation_link=invitation_link,
                            inviter_name=inviter_name
                        )
                    )
                else:
                    # If no loop running, run async
                    loop.run_until_complete(
                        self.email_service.send_user_invitation(
                            email=command.email,
                            company_name=company_name,
                            invitation_link=invitation_link,
                            inviter_name=inviter_name
                        )
                    )
            except RuntimeError:
                # No event loop, create new one
                asyncio.run(
                    self.email_service.send_user_invitation(
                        email=command.email,
                        company_name=company_name,
                        invitation_link=invitation_link,
                        inviter_name=inviter_name
                    )
                )
        except Exception as e:
            # Log error but don't fail the command if email fails
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Failed to send invitation email: {str(e)}")
            # Email failure should not prevent invitation creation

